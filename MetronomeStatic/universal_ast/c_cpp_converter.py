"""
Evaluate AST generated by libclang.

The evaluation input can be either concrete value or z3 symbolic variable.
"""

from copy import deepcopy
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    List,
    Optional,
    Tuple,
    TypeVar,
    TypedDict,
    Union,
)

from clang.cindex import Cursor, CursorKind, Token

from ..clang_utils.code_attributes.extract_data_structure import (
    FunctionDefModel,
)
from ..clang_utils.code_attributes.utils import TraversalContext


from ..clang_utils.code_attributes import (
    UnaryOpPos,
    extract_literal_value,
    split_binary_operator,
    split_for_loop_conditions,
    split_unary_operator,
    split_compound_assignment,
    traversal_with_callback,
)
from ..utils.functional import SkyGenerator
from .exceptions import FunctionReturn, OnBreakStatement
from .models import (
    DATA_TYPE,
    ArrayValue,
    ConcreteValueType,
    PointerValue,
    StructValue,
    Variable,
)
from .program_info import ProgramInfo
from ..universal_ast import universal_ast_nodes as nodes

if TYPE_CHECKING:
    CursorKind: Any = CursorKind

T = TypeVar("T")


def first_child(c: Cursor) -> Cursor:
    return next(c.get_children())


def ensure_not_none(val: Optional[T]) -> T:
    assert val is not None
    return val


class LabelDesc(TypedDict):
    parent_offset: int
    label: str
    index: int


class NotImplementedItem:
    def __init__(self, tag) -> None:
        self.tag = tag

    def __repr__(self) -> str:
        return f"<NotimplementedItem {self.tag}>"


class ClangASTConverter:
    def __init__(
        self,
    ) -> None:

        self._handlers_map = {
            # TRANSLATIONS
            CursorKind.TRANSLATION_UNIT: lambda c: nodes.CompilationUnit(
                self.eval_children(c)
            ),
            # DECLARATIONS
            CursorKind.STRUCT_DECL: lambda c: NotImplementedItem("structdecl"),
            CursorKind.TYPEDEF_DECL: lambda c: NotImplementedItem("typedefdecl"),
            CursorKind.DECL_STMT: self.eval_children,
            CursorKind.VAR_DECL: self._handle_var_decl,
            CursorKind.PARM_DECL: lambda c: None,
            CursorKind.FUNCTION_DECL: self._handle_function_decl,
            # EXPRESSIONS
            CursorKind.DECL_REF_EXPR: lambda c: nodes.Name(c.spelling),
            CursorKind.MEMBER_REF_EXPR: self._handle_member_ref_expr,
            CursorKind.ARRAY_SUBSCRIPT_EXPR: self._handle_array_subscript_expr,
            CursorKind.UNEXPOSED_EXPR: lambda c: self.eval_children(c)[0],
            CursorKind.INIT_LIST_EXPR: self._handle_init_list_expr,
            CursorKind.CALL_EXPR: self._handle_call_expr,
            # TYPES
            CursorKind.TYPE_REF: lambda c: nodes.Type(c.spelling),
            # LITERALS
            CursorKind.INTEGER_LITERAL: lambda c: int(
                ensure_not_none(extract_literal_value(c))
            ),
            # OPERATORS
            CursorKind.BINARY_OPERATOR: self._handle_binary_operator,
            CursorKind.UNARY_OPERATOR: self._handle_unary_operator,
            CursorKind.COMPOUND_ASSIGNMENT_OPERATOR: self._handle_compound_assignment_operator,
            # STATEMENTS
            CursorKind.COMPOUND_STMT: lambda c: nodes.Block(self.eval_children(c)),
            CursorKind.IF_STMT: self._handle_if_stmt,
            CursorKind.FOR_STMT: self._handle_for_stmt,
            CursorKind.GOTO_STMT: self._handle_goto_stmt,
            CursorKind.LABEL_STMT: self._handle_label_stmt,
            CursorKind.WHILE_STMT: self._handle_while_stmt,
            CursorKind.SWITCH_STMT: self._handle_switch_stmt,
            # CursorKind.DO_STMT: self._handle_do_stmt,
            CursorKind.BREAK_STMT: lambda c: nodes.Break(
                self.eval_single_cursor(next(c.get_children()))
                if len(list(c.get_children())) > 0
                else None
            ),
            CursorKind.CONTINUE_STMT: lambda c: nodes.Continue(
                self.eval_single_cursor(next(c.get_children()))
                if len(list(c.get_children())) > 0
                else None
            ),
            # CursorKind.GOTO_STMT: lambda c: None,
            # CursorKind.CASE_STMT: lambda c: None,
            CursorKind.RETURN_STMT: self._handle_return_stmt,
        }

        # Return value of execution
        self._ret_value = None
        self._labels: Dict[str, LabelDesc] = {}

    def _calc_add_add_expression(self, c: Cursor, pos: UnaryOpPos) -> Variable:
        """
        TODO: finish this file
        """
        raise NotImplementedError
        # return nodes.Unary('++', c.)

    def _calc_reference_expression(self, c: Cursor) -> nodes.ReferenceExpr:
        referenced_variable = self.eval_single_cursor(c)
        return nodes.ReferenceExpr(referenced_variable)

    def _calc_dereference_expression(self, c: Cursor) -> nodes.DereferenceExpr:
        result = self.eval_single_cursor(c)
        return nodes.DereferenceExpr(result)

    def eval_single_cursor(self, cursor: Cursor):
        return self._handlers_map[cursor.kind](cursor)

    def eval_children(self, cursor: Cursor) -> List:
        children_values = []
        for child in cursor.get_children():
            children_values.append(self.eval_single_cursor(child))
        return children_values

    def eval(self, cursor: Cursor):
        try:
            return self.eval_single_cursor(cursor)
        except FunctionReturn as e:
            self._ret_value = e.value
            return self._ret_value

    def _handle_function_decl(self, cursor: Cursor) -> nodes.MethodDeclaration:
        children_values = self.eval_children(cursor)
        params_ast = (
            (children_values[: len(children_values) - 1])
            if len(children_values) > 1
            else []
        )
        body_ast = children_values[-1]
        return nodes.MethodDeclaration(
            cursor.spelling, [], [], params_ast, "NotImplemented", body_ast
        )

    def _handle_var_decl(self, cursor: Cursor) -> Optional[nodes.Assignment]:
        children_asts = (
            SkyGenerator(cursor.get_children())
            .filter(lambda c: c.kind not in (CursorKind.TYPE_REF,))
            .l
        )
        if len(children_asts) >= 1:
            l_value = nodes.Name(cursor.spelling)
            r_value = self.eval_single_cursor(children_asts[-1])
            return nodes.Assignment("=", l_value, r_value)

    def _handle_member_ref_expr(self, cursor: Cursor) -> nodes.FieldAccess:
        referenced_variable = self.eval_single_cursor(first_child(cursor))
        return nodes.FieldAccess(cursor.spelling, referenced_variable)

    def _handle_array_subscript_expr(self, cursor: Cursor) -> nodes.ArrayAccess:
        array_ref_ast, indexer_ast = cursor.get_children()
        array = self.eval_single_cursor(array_ref_ast)
        index: int = self.eval_single_cursor(indexer_ast)
        return nodes.ArrayAccess(index, array)

    def _handle_unary_operator(self, cursor: Cursor) -> nodes.Unary:
        op, operand, pos = split_unary_operator(cursor)
        if pos == UnaryOpPos.BEFORE:
            op = "p" + op
        return nodes.Unary(op, self.eval_single_cursor(operand))

    def _handle_binary_operator(
        self, cursor: Cursor
    ) -> Union[nodes.Assignment, nodes.BinaryExpression]:
        l_ast, symbol, r_ast = split_binary_operator(cursor)
        if symbol == "=":
            return nodes.Assignment(
                "=", self.eval_single_cursor(l_ast), self.eval_single_cursor(r_ast)
            )
        else:
            value_left, value_right = self.eval_children(cursor)
            return nodes.BinaryExpression(symbol, value_left, value_right)

    def _handle_compound_assignment_operator(self, cursor: Cursor) -> nodes.Assignment:
        l_value, op, r_value = split_compound_assignment(cursor)
        return nodes.Assignment(
            op, self.eval_single_cursor(l_value), self.eval_single_cursor(r_value)
        )

    def _handle_call_expr(self, cursor: Cursor) -> nodes.FuncCall:
        callee_ast, *args_ast = cursor.get_children()
        arg_values = [self.eval_single_cursor(item) for item in args_ast]
        callee_value = self.eval_single_cursor(callee_ast)
        return nodes.FuncCall(callee_value, arg_values)

    def _handle_init_list_expr(self, cursor: Cursor) -> nodes.ArrayInitializer:
        children_values = self.eval_children(cursor)
        return nodes.ArrayInitializer(children_values)

    def _handle_if_stmt(self, cursor: Cursor) -> nodes.IfThenElse:
        children: List[Cursor] = list(cursor.get_children())
        condition_ast = children[0]
        assert len(children) in (2, 3)
        if len(children) == 2:
            return nodes.IfThenElse(
                self.eval_single_cursor(condition_ast),
                self.eval_single_cursor(children[1]),
            )
        elif len(children) == 3:
            return nodes.IfThenElse(
                self.eval_single_cursor(condition_ast),
                self.eval_single_cursor(children[1]),
                self.eval_single_cursor(children[2]),
            )
        else:
            raise NotImplementedError(len(children))

    def _handle_goto_stmt(self, cursor: Cursor):

        return nodes.GoToStatement(next(cursor.get_children()).spelling)

    def _handle_label_stmt(self, cursor: Cursor):
        return nodes.Label(
            cursor.spelling, self.eval_single_cursor(next(cursor.get_children()))
        )

    def _handle_while_stmt(self, cursor: Cursor):
        cond_ast, body_ast = self.eval_children(cursor)
        return nodes.While(cond_ast, body_ast)

    def _handle_switch_stmt(self, cursor: Cursor) -> nodes.Switch:
        condition_cursor, switch_body_cursor = cursor.get_children()
        assert switch_body_cursor.kind == CursorKind.COMPOUND_STMT
        switch_body_item_cursor: Cursor
        switch_cases: List[nodes.SwitchCase] = []
        default_procedure = None
        # Get switch items from body cursor
        for switch_body_item_cursor in switch_body_cursor.get_children():
            if switch_body_item_cursor.kind == CursorKind.CASE_STMT:
                case_cond, body = self.eval_children(switch_body_item_cursor)
                switch_cases.append(nodes.SwitchCase(case_cond, body))
            elif switch_body_item_cursor.kind == CursorKind.DEFAULT_STMT:
                body = self.eval_children(switch_body_item_cursor)[0]
                switch_cases.append(nodes.SwitchCase(nodes.DefaultStatement(), body))
            elif switch_body_item_cursor.kind in (CursorKind.BREAK_STMT,):
                if not isinstance(switch_cases[-1].body, nodes.Block):
                    switch_cases[-1].body = nodes.Block([switch_cases[-1].body])
                if switch_body_item_cursor.kind == CursorKind.BREAK_STMT:
                    switch_cases[-1].body.statements.append(
                        self.eval_single_cursor(switch_body_item_cursor)
                    )
                # elif switch_body_item_cursor.kind == CursorKind.DEFAULT_STMT:

            else:
                raise NotImplementedError
        return nodes.Switch(self.eval_single_cursor(condition_cursor), switch_cases)

    def _handle_for_stmt(self, cursor: Cursor):
        stmt1_cursor, cond_expr_cursor, stmt2_cursor, body_cursor = (
            split_for_loop_conditions(cursor)
        )
        if stmt1_cursor is not None:
            stmt1_ast = self.eval_single_cursor(stmt1_cursor)
        if stmt2_cursor is not None:
            stmt2_ast = self.eval_single_cursor(stmt2_cursor)
        if cond_expr_cursor is not None:
            cond_ast = self.eval_single_cursor(cond_expr_cursor)
        if body_cursor is not None:
            body_ast = self.eval_single_cursor(body_cursor)
        return nodes.For(stmt1_ast, cond_ast, stmt2_ast, body_ast)

    def _handle_return_stmt(self, cursor: Cursor) -> nodes.Return:
        children_values = self.eval_children(cursor)
        if len(children_values) > 0:
            val = children_values[0]
            return nodes.Return(val)
        else:
            return nodes.Return()

    def get_func(self, c: Cursor) -> Tuple[Cursor, FunctionDefModel]:
        if c.kind == CursorKind.DECL_REF_EXPR:
            return self._program_info.get_function_ast(
                c.spelling
            ), self._program_info.get_function_structure(c.spelling)
        elif c.kind == CursorKind.UNEXPOSED_EXPR:
            return self.get_func(first_child(c))
        else:
            raise KeyError(c.kind)

    def is_concrete_value(self, value: Any) -> bool:
        if isinstance(value, (int, float, bool, str)) or value is None:
            return True
        else:
            return False
