"""
Evaluate AST generated by libclang.

The evaluation input can be either concrete value or z3 symbolic variable.
"""

from copy import deepcopy
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    List,
    Optional,
    Tuple,
    TypeVar,
    TypedDict,
    Union,
)

from clang.cindex import Cursor, CursorKind, Token

from ..clang_utils.code_attributes.extract_data_structure import (
    FunctionDefModel,
)
from ..clang_utils.code_attributes.utils import TraversalContext


from ..clang_utils.code_attributes import (
    UnaryOpPos,
    extract_literal_value,
    split_binary_operator,
    split_for_loop_conditions,
    split_unary_operator,
    split_compound_assignment,
    traversal_with_callback,
)
from ..utils.functional import SkyGenerator
from .exceptions import FunctionReturn
from .models import (
    DATA_TYPE,
    ArrayValue,
    ConcreteValueType,
    PointerValue,
    StructValue,
    Variable,
)
from .program_info import ProgramInfo
from ..universal_ast import universal_ast_nodes as nodes

if TYPE_CHECKING:
    CursorKind: Any = CursorKind

T = TypeVar("T")


def first_child(c: Cursor) -> Cursor:
    return next(c.get_children())


def ensure_not_none(val: Optional[T]) -> T:
    assert val is not None
    return val


class LabelDesc(TypedDict):
    parent_offset: int
    label: str
    index: int


def get_labels(c: Cursor) -> Dict[str, LabelDesc]:
    assert c.kind == CursorKind.FUNCTION_DECL
    labels: Dict[str, LabelDesc] = {}

    def _handle_traversal(ctx: TraversalContext):
        if ctx.current_node.kind == CursorKind.LABEL_STMT:
            label_parent: Cursor = ctx.hierarchy[-2]
            assert label_parent.kind == CursorKind.COMPOUND_STMT
            for i, child in enumerate(label_parent.get_children()):
                if child.spelling == ctx.current_node.spelling:
                    labels[ctx.current_node.spelling] = {
                        "parent_offset": label_parent.location.offset,
                        "label": ctx.current_node.spelling,
                        "index": i,
                    }
                    return

    traversal_with_callback(c, _handle_traversal)
    return labels


class ClangASTConverter:
    def __init__(
        self,
        initial_params: Optional[Dict[str, Any]] = None,
        initial_locals: Optional[Dict[str, Any]] = None,
        initial_globals: Optional[Dict[str, Any]] = None,
        types: Optional[Dict[str, Optional[DATA_TYPE]]] = None,
        program_info: Optional[ProgramInfo] = None,
    ) -> None:
        self.initial_params = {} if initial_params is None else initial_params
        self.initial_locals = {} if initial_locals is None else initial_locals
        self.initial_globals = {} if initial_globals is None else initial_globals
        self.variables: Dict[str, Variable] = {}
        self._program_info = (
            program_info if program_info is not None else ProgramInfo({})
        )
        self.types = {} if types is None else types
        for k, v in self.initial_params.items():
            self.variables[k] = deepcopy(v)
        for k, v in self.initial_globals.items():
            self.variables[k] = deepcopy(v)
        for k, v in self.initial_locals.items():
            self.variables[k] = deepcopy(v)
        self._handlers_map = {
            # DECLARATIONS
            CursorKind.DECL_STMT: self.eval_children,
            CursorKind.VAR_DECL: self._handle_var_decl,
            CursorKind.PARM_DECL: lambda c: None,
            CursorKind.FUNCTION_DECL: self.eval_children,
            # EXPRESSIONS
            CursorKind.DECL_REF_EXPR: lambda c: self.get_variable(c).value,
            CursorKind.MEMBER_REF_EXPR: self._handle_member_ref_expr,
            CursorKind.ARRAY_SUBSCRIPT_EXPR: self._handle_array_subscript_expr,
            CursorKind.UNEXPOSED_EXPR: lambda c: self.eval_children(c)[0],
            CursorKind.INIT_LIST_EXPR: self._handle_init_list_expr,
            CursorKind.CALL_EXPR: self._handle_call_expr,
            # TYPES
            CursorKind.TYPE_REF: lambda c: None,
            # LITERALS
            CursorKind.INTEGER_LITERAL: lambda c: int(
                ensure_not_none(extract_literal_value(c))
            ),
            # OPERATORS
            CursorKind.BINARY_OPERATOR: self._handle_binary_operator,
            CursorKind.UNARY_OPERATOR: self._handle_unary_operator,
            CursorKind.COMPOUND_ASSIGNMENT_OPERATOR: self._handle_compound_assignment_operator,
            # STATEMENTS
            CursorKind.COMPOUND_STMT: self.eval_children,
            CursorKind.IF_STMT: self._handle_if_stmt,
            CursorKind.FOR_STMT: self._handle_for_stmt,
            CursorKind.GOTO_STMT: self._handle_goto_stmt,
            CursorKind.LABEL_STMT: self._handle_label_stmt,
            # CursorKind.WHILE_STMT: self._handle_while_stmt,
            # CursorKind.DO_STMT: self._handle_do_stmt,
            # CursorKind.BREAK_STMT: lambda c: None,
            # CursorKind.CONTINUE_STMT: lambda c: None,
            # CursorKind.GOTO_STMT: lambda c: None,
            # CursorKind.CASE_STMT: lambda c: None,
            CursorKind.RETURN_STMT: self._handle_return_stmt,
        }
        self._methods_unary_op: Dict[
            Tuple[str, UnaryOpPos], Callable[[Cursor], Variable]
        ] = {
            ("*", UnaryOpPos.BEFORE): self._calc_dereference_expression,
            ("&", UnaryOpPos.BEFORE): self._calc_reference_expression,
            ("++", UnaryOpPos.AFTER): lambda c: self._calc_add_add_expression(
                c, UnaryOpPos.AFTER
            ),
            ("++", UnaryOpPos.BEFORE): lambda c: self._calc_add_add_expression(
                c, UnaryOpPos.BEFORE
            ),
            ("-", UnaryOpPos.BEFORE): lambda c: Variable(
                self.eval_single_cursor(c) * -1
            ),
        }
        self._methods_binary_op: Dict[
            str, Callable[[ConcreteValueType, ConcreteValueType], ConcreteValueType]
        ] = {
            "+": lambda a, b: a + b,
            "-": lambda a, b: a - b,
            "*": lambda a, b: a * b,
            "/": lambda a, b: a / b,
            "%": lambda a, b: a % b,
            "==": lambda a, b: int(a == b),
            "!=": lambda a, b: int(a != b),
            "<": lambda a, b: int(a < b),
            ">": lambda a, b: int(a > b),
            ">=": lambda a, b: int(a >= b),
            "&&": lambda a, b: a & b,
        }

        # Return value of execution
        self._ret_value = None
        self._labels: Dict[str, LabelDesc] = {}

    def _calc_add_add_expression(self, c: Cursor, pos: UnaryOpPos) -> Variable:
        """
        TODO: finish this file
        """
        raise NotImplementedError
        # return nodes.Unary('++', c.)

    def _calc_reference_expression(self, c: Cursor) -> nodes.ReferenceExpr:
        referenced_variable = self.eval_single_cursor(c)
        return nodes.ReferenceExpr(referenced_variable)

    def _calc_dereference_expression(self, c: Cursor) -> nodes.DereferenceExpr:
        result = self.eval_single_cursor(c)
        return nodes.DereferenceExpr(result)

    def eval_single_cursor(self, cursor: Cursor):
        return self._handlers_map[cursor.kind](cursor)

    def eval_children(self, cursor: Cursor) -> List:
        children_values = []
        for child in cursor.get_children():
            children_values.append(self.eval_single_cursor(child))
        return children_values

    def eval(self, cursor: Cursor):
        self._labels = get_labels(cursor)
        try:
            return self.eval_single_cursor(cursor)
        except FunctionReturn as e:
            self._ret_value = e.value
            return self._ret_value

    def _handle_var_decl(self, cursor: Cursor) -> Optional[nodes.Assignment]:
        children_asts = (
            SkyGenerator(cursor.get_children())
            .filter(lambda c: c.kind not in (CursorKind.TYPE_REF,))
            .l
        )
        if len(children_asts) >= 1:
            l_value = nodes.Name(cursor.spelling)
            r_value = self.eval_single_cursor(children_asts[-1])
            return nodes.Assignment("=", l_value, r_value)

    def _handle_member_ref_expr(self, cursor: Cursor) -> nodes.FieldAccess:
        referenced_variable = self.eval_single_cursor(first_child(cursor))
        return nodes.FieldAccess(cursor.spelling, referenced_variable)

    def _handle_array_subscript_expr(self, cursor: Cursor) -> nodes.ArrayAccess:
        array_ref_ast, indexer_ast = cursor.get_children()
        array = self.eval_single_cursor(array_ref_ast)
        index: int = self.eval_single_cursor(indexer_ast)
        return nodes.ArrayAccess(index, array)

    def _handle_unary_operator(self, cursor: Cursor) -> nodes.Unary:
        op, operand, pos = split_unary_operator(cursor)
        if pos == UnaryOpPos.BEFORE:
            op = "p" + op
        return nodes.Unary(op, self.eval_single_cursor(operand))

    def _handle_binary_operator(
        self, cursor: Cursor
    ) -> Union[nodes.Assignment, nodes.BinaryExpression]:
        l_ast, symbol, r_ast = split_binary_operator(cursor)
        if symbol == "=":
            return nodes.Assignment(
                "=", self.eval_single_cursor(l_ast), self.eval_single_cursor(r_ast)
            )
        else:
            value_left, value_right = self.eval_children(cursor)
            return nodes.BinaryExpression(symbol, value_left, value_right)

    def _handle_compound_assignment_operator(self, cursor: Cursor) -> nodes.Assignment:
        l_value, op, r_value = split_compound_assignment(cursor)
        return nodes.Assignment(
            op, self.eval_single_cursor(l_value), self.eval_single_cursor(r_value)
        )

    def _handle_call_expr(self, cursor: Cursor) -> nodes.FuncCall:
        callee_ast, *args_ast = cursor.get_children()
        arg_values = [self.eval_single_cursor(item) for item in args_ast]
        callee_value = self.eval_single_cursor(callee_ast)
        return nodes.FuncCall(callee_value, arg_values)

    def _handle_init_list_expr(self, cursor: Cursor) -> nodes.ArrayInitializer:
        children_values = self.eval_children(cursor)
        return nodes.ArrayInitializer(children_values)

    def _handle_if_stmt(self, cursor: Cursor) -> nodes.IfThenElse:
        children: List[Cursor] = list(cursor.get_children())
        condition_ast = children[0]
        assert len(children) in (2, 3)
        if len(children) == 2:
            return nodes.IfThenElse(
                self.eval_single_cursor(condition_ast),
                self.eval_single_cursor(children[1]),
            )
        elif len(children) == 3:
            return nodes.IfThenElse(
                self.eval_single_cursor(condition_ast),
                self.eval_single_cursor(children[1]),
                self.eval_single_cursor(children[2]),
            )
        else:
            raise NotImplementedError(len(children))

    def _handle_goto_stmt(self, cursor: Cursor):
        raise NotImplementedError

    def _handle_label_stmt(self, cursor: Cursor):
        raise NotImplementedError

    def _handle_for_stmt(self, cursor: Cursor):
        stmt1_ast, cond_expr_ast, stmt2_ast, body_ast = split_for_loop_conditions(
            cursor
        )
        if stmt1_ast is not None:
            self.eval_single_cursor(stmt1_ast)
        while (cond_expr_ast is None) or (self.eval_single_cursor(cond_expr_ast) != 0):
            if body_ast is not None:
                self.eval_single_cursor(body_ast)
            if stmt2_ast is not None:
                self.eval_single_cursor(stmt2_ast)

    def _handle_return_stmt(self, cursor: Cursor):
        children_values = self.eval_children(cursor)
        if len(children_values) > 0:
            val = children_values[0]
            self._ret_value = val
            raise FunctionReturn(val)
        else:
            return None

    def get_func(self, c: Cursor) -> Tuple[Cursor, FunctionDefModel]:
        if c.kind == CursorKind.DECL_REF_EXPR:
            return self._program_info.get_function_ast(
                c.spelling
            ), self._program_info.get_function_structure(c.spelling)
        elif c.kind == CursorKind.UNEXPOSED_EXPR:
            return self.get_func(first_child(c))
        else:
            raise KeyError(c.kind)

    def is_concrete_value(self, value: Any) -> bool:
        if isinstance(value, (int, float, bool, str)) or value is None:
            return True
        else:
            return False

    def assign_value_to_target(self, target: Variable, value: Any):
        if isinstance(target.value, ArrayValue):
            for i, v in enumerate(target.value.values):
                self.assign_value_to_target(v, value[i].value)
        elif isinstance(target.value, StructValue):
            for i, item in enumerate(target.value.attributes.items()):
                k, v = item
                self.assign_value_to_target(v, value[i].value)
        elif isinstance(target.value, PointerValue):
            assert isinstance(value, PointerValue), value
            target.value.pointee = value.pointee
            # raise NotImplementedError
        elif self.is_concrete_value(target.value):
            target.value = value
        else:
            raise NotImplementedError(target.value)
