"""
Evaluate AST generated by libclang.

The evaluation input can be either concrete value or z3 symbolic variable.
"""

from copy import deepcopy
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    List,
    Optional,
    Tuple,
    TypeVar,
    TypedDict,
    Union,
)

from clang.cindex import Cursor, CursorKind, Token

from ..clang_utils.code_attributes.extract_data_structure import (
    FunctionDefModel,
)
from ..clang_utils.code_attributes.utils import TraversalContext


from ..clang_utils.code_attributes import (
    UnaryOpPos,
    extract_literal_value,
    split_binary_operator,
    split_for_loop_conditions,
    split_unary_operator,
    split_compound_assignment,
    traversal_with_callback,
    is_function_definition,
)
from ..utils.functional import MelodieGenerator
from .exceptions import FunctionReturn, OnBreakStatement
from .models import (
    DATA_TYPE,
    ArrayValue,
    ConcreteValueType,
    PointerValue,
    StructValue,
    Variable,
)
from .program_info import ProgramInfo
from ..universal_ast import universal_ast_nodes as nodes

if TYPE_CHECKING:
    CursorKind: Any = CursorKind

T = TypeVar("T")


def first_child(c: Cursor) -> Cursor:
    return next(c.get_children())


def ensure_not_none(val: Optional[T]) -> T:
    assert val is not None
    return val


# def str_to_int(s)->T


class LabelDesc(TypedDict):
    parent_offset: int
    label: str
    index: int


class NotImplementedItem(nodes.SourceElement):
    _fields = ["kind"]

    def __init__(self, kind: str) -> None:
        self.kind = kind

    def __repr__(self) -> str:
        return f"<NotimplementedItem {self.kind}>"

    # def


class ClangASTConverter:
    def __init__(
        self,
    ) -> None:

        self._handlers_map = {
            # TRANSLATIONS
            CursorKind.TRANSLATION_UNIT: lambda c: nodes.CompilationUnit(
                self.eval_children(c)
            ),
            # DECLARATIONS
            CursorKind.ENUM_DECL: self._handle_enum_decl,
            CursorKind.STRUCT_DECL: self._handle_struct_decl,
            CursorKind.TYPEDEF_DECL: self._handle_typedef_decl,
            CursorKind.FIELD_DECL: self._handle_field_decl,
            CursorKind.UNION_DECL: self._handle_union_decl,
            CursorKind.DECL_STMT: self.eval_children,
            CursorKind.VAR_DECL: self._handle_var_decl,
            CursorKind.PARM_DECL: lambda c: None,
            CursorKind.UNEXPOSED_DECL: self._handle_notimplemented,
            CursorKind.FUNCTION_DECL: self._handle_function_decl,
            CursorKind.ASM_STMT: self._handle_notimplemented,
            CursorKind.NAMESPACE: self._handle_namespace,
            # ATTRIBUTES
            CursorKind.UNEXPOSED_ATTR: self._handle_notimplemented,
            CursorKind.DLLIMPORT_ATTR: self._handle_notimplemented,
            CursorKind.PURE_ATTR: self._handle_notimplemented,
            # EXPRESSIONS
            CursorKind.DECL_REF_EXPR: lambda c: nodes.Name(c.spelling),
            CursorKind.MEMBER_REF_EXPR: self._handle_member_ref_expr,
            CursorKind.ARRAY_SUBSCRIPT_EXPR: self._handle_array_subscript_expr,
            CursorKind.UNEXPOSED_EXPR: lambda c: self.eval_children(c)[0],
            CursorKind.CSTYLE_CAST_EXPR: self._handle_cstyle_cast_expr,
            CursorKind.PAREN_EXPR: lambda c: self.eval_children(c)[0],
            CursorKind.INIT_LIST_EXPR: self._handle_init_list_expr,
            CursorKind.CALL_EXPR: self._handle_call_expr,
            CursorKind.CXX_UNARY_EXPR: self._handle_cxx_unary_expr,
            CursorKind.CONDITIONAL_OPERATOR: self._handle_conditional_operator,
            CursorKind.ADDR_LABEL_EXPR: self._handle_addr_label_expr,
            CursorKind.USING_DIRECTIVE: lambda c: nodes.Using(
                self.eval_single_cursor(next(c.get_children()))
            ),
            CursorKind.NAMESPACE_REF: lambda c: nodes.NameSpaceRef(
                c.spelling
            ),
            # TYPES
            CursorKind.TYPE_REF: lambda c: nodes.Type(c.spelling),
            # LITERALS
            CursorKind.INTEGER_LITERAL: lambda c: nodes.Literal(
                ensure_not_none(extract_literal_value(c)), "int"
            ),
            CursorKind.STRING_LITERAL: lambda c: nodes.Literal(
                ensure_not_none(extract_literal_value(c)), "str"
            ),
            # OPERATORS
            CursorKind.BINARY_OPERATOR: self._handle_binary_operator,
            CursorKind.UNARY_OPERATOR: self._handle_unary_operator,
            CursorKind.COMPOUND_ASSIGNMENT_OPERATOR: self._handle_compound_assignment_operator,
            # STATEMENTS
            CursorKind.COMPOUND_STMT: lambda c: nodes.Block(self.eval_children(c)),
            CursorKind.IF_STMT: self._handle_if_stmt,
            CursorKind.FOR_STMT: self._handle_for_stmt,
            CursorKind.GOTO_STMT: self._handle_goto_stmt,
            CursorKind.INDIRECT_GOTO_STMT: self._handle_indirect_goto_stmt,
            CursorKind.LABEL_STMT: self._handle_label_stmt,
            CursorKind.WHILE_STMT: self._handle_while_stmt,
            CursorKind.SWITCH_STMT: self._handle_switch_stmt,
            CursorKind.CASE_STMT: self._handle_case_stmt,
            CursorKind.DO_STMT: self._handle_do_stmt,
            CursorKind.BREAK_STMT: lambda c: nodes.Break(
                self.eval_single_cursor(next(c.get_children()))
                if len(list(c.get_children())) > 0
                else None
            ),
            CursorKind.NULL_STMT: self._handle_notimplemented,
            CursorKind.CONTINUE_STMT: lambda c: nodes.Continue(
                self.eval_single_cursor(next(c.get_children()))
                if len(list(c.get_children())) > 0
                else None
            ),
            # CursorKind.GOTO_STMT: lambda c: None,
            # CursorKind.CASE_STMT: lambda c: None,
            CursorKind.RETURN_STMT: self._handle_return_stmt,
        }

        # Return value of execution
        self._ret_value = None
        self._labels: Dict[str, LabelDesc] = {}

    def _handle_notimplemented(self, c: Cursor) -> NotImplementedItem:
        return NotImplementedItem(str(c.kind))

    def _calc_add_add_expression(self, c: Cursor, pos: UnaryOpPos) -> Variable:
        """
        TODO: finish this file
        """
        raise NotImplementedError
        # return nodes.Unary('++', c.)

    def _calc_reference_expression(self, c: Cursor) -> nodes.ReferenceExpr:
        referenced_variable = self.eval_single_cursor(c)
        return nodes.ReferenceExpr(referenced_variable)

    def _calc_dereference_expression(self, c: Cursor) -> nodes.DereferenceExpr:
        result = self.eval_single_cursor(c)
        return nodes.DereferenceExpr(result)

    def eval_single_cursor(self, cursor: Cursor):
        try:
            return self._handlers_map[cursor.kind](cursor)
        except Exception as e:
            print("error occurred in cursor", cursor.location)
            raise e

    def eval_children(self, cursor: Cursor) -> List:
        children_values = []
        for child in cursor.get_children():
            children_values.append(self.eval_single_cursor(child))
        return children_values

    def eval(self, cursor: Cursor) -> nodes.SourceElement:
        try:
            return self.eval_single_cursor(cursor)
        except FunctionReturn as e:
            self._ret_value = e.value
            return self._ret_value

    def _handle_function_decl(self, cursor: Cursor) -> nodes.MethodDeclaration:
        children_values = self.eval_children(cursor)
        params_ast = (
            (children_values[: len(children_values) - 1])
            if len(children_values) > 1
            else []
        )
        if is_function_definition(cursor):
            body_ast = children_values[-1]
        else:
            body_ast = None
        return nodes.MethodDeclaration(
            cursor.spelling, [], [], params_ast, "NotImplemented", body_ast
        )

    def _handle_cstyle_cast_expr(self, cursor: Cursor) -> nodes.Cast:
        return nodes.Cast(
            cursor.type.spelling, self.eval_single_cursor(next(cursor.get_children()))
        )

    def _handle_enum_decl(self, cursor: Cursor) -> Optional[nodes.EnumDeclaration]:
        # import pdb; pdb.set_trace()
        enum_children = []
        child: Cursor
        for child in cursor.get_children():
            enum_children.append(nodes.EnumConstant(child.spelling, child.enum_value))
        return nodes.EnumDeclaration(cursor.spelling, enum_children)

    def _handle_struct_decl(self, cursor: Cursor) -> Optional[nodes.StructDeclaration]:
        assert cursor.kind == CursorKind.STRUCT_DECL, "Expected a STRUCT_DECL cursor"

        m = nodes.StructDeclaration(cursor.spelling, [])

        for child in cursor.get_children():
            m.fields.append(self.eval_single_cursor(child))

        return m

    def _handle_union_decl(self, cursor: Cursor) -> Optional[nodes.UnionDeclaration]:
        assert cursor.kind == CursorKind.UNION_DECL, "Expected a UNION_DECL cursor"

        m = nodes.UnionDeclaration(cursor.spelling, [])

        for child in cursor.get_children():
            m.children.append(self.eval_single_cursor(child))

        return m

    def _handle_typedef_decl(self, cursor: Cursor) -> nodes.Type:
        children = list(cursor.get_children())

        child: Optional[nodes.SourceElement] = (
            self.eval_single_cursor(children[0]) if len(children) > 0 else None
        )
        return nodes.Type(cursor.spelling, child)

    def _handle_field_decl(self, cursor: Cursor) -> nodes.FieldDeclaration:
        assert cursor.kind == CursorKind.FIELD_DECL
        children: List[Cursor] = list(cursor.get_children())
        init_value: Optional[str] = None
        if len(children) == 1:
            init_value = extract_literal_value(children[0])

        return nodes.FieldDeclaration(cursor.spelling, cursor.type.spelling, init_value)

    def _handle_var_decl(self, cursor: Cursor) -> Optional[nodes.Assignment]:
        children_asts = (
            MelodieGenerator(cursor.get_children())
            .filter(lambda c: c.kind not in (CursorKind.TYPE_REF,))
            .l
        )
        if len(children_asts) >= 1:
            l_value = nodes.Name(cursor.spelling)
            r_value = self.eval_single_cursor(children_asts[-1])
            return nodes.Assignment("=", l_value, r_value)

    def _handle_member_ref_expr(self, cursor: Cursor) -> nodes.FieldAccess:
        referenced_variable = self.eval_single_cursor(first_child(cursor))
        return nodes.FieldAccess(cursor.spelling, referenced_variable)

    def _handle_array_subscript_expr(self, cursor: Cursor) -> nodes.ArrayAccess:
        array_ref_ast, indexer_ast = cursor.get_children()
        array = self.eval_single_cursor(array_ref_ast)
        index: int = self.eval_single_cursor(indexer_ast)
        return nodes.ArrayAccess(index, array)

    def _handle_unary_operator(self, cursor: Cursor) -> nodes.Unary:
        op, operand, pos = split_unary_operator(cursor)
        if pos == UnaryOpPos.BEFORE:
            op = "p" + op
        return nodes.Unary(op, self.eval_single_cursor(operand))

    def _handle_binary_operator(
        self, cursor: Cursor
    ) -> Union[nodes.Assignment, nodes.BinaryExpression]:
        l_ast, symbol, r_ast = split_binary_operator(cursor)
        if symbol == "=":
            return nodes.Assignment(
                "=", self.eval_single_cursor(l_ast), self.eval_single_cursor(r_ast)
            )
        else:
            value_left, value_right = self.eval_children(cursor)
            return nodes.BinaryExpression(symbol, value_left, value_right)

    def _handle_compound_assignment_operator(self, cursor: Cursor) -> nodes.Assignment:
        l_value, op, r_value = split_compound_assignment(cursor)
        return nodes.Assignment(
            op, self.eval_single_cursor(l_value), self.eval_single_cursor(r_value)
        )

    def _handle_call_expr(self, cursor: Cursor) -> nodes.FuncCall:
        callee_ast, *args_ast = cursor.get_children()
        arg_values = [self.eval_single_cursor(item) for item in args_ast]
        callee_value = self.eval_single_cursor(callee_ast)
        return nodes.FuncCall(callee_value, arg_values)

    def _handle_cxx_unary_expr(self, cursor: Cursor) -> nodes.SpecialOperator:
        tokens = [
            t.spelling for t in cursor.get_tokens() if t.spelling not in ("(", ")")
        ]

        # handle sizeof
        if tokens[0] == "sizeof":
            return nodes.SpecialOperator("sizeof", tokens[1:])
        else:
            raise NotImplementedError

    def _handle_conditional_operator(self, cursor: Cursor) -> nodes.Conditional:
        pred, if_true, if_false = self.eval_children(cursor)
        return nodes.Conditional(pred, if_true, if_false)

    def _handle_addr_label_expr(self, cursor: Cursor) -> nodes.AddressLabel:
        return nodes.AddressLabel(cursor.spelling)

    def _handle_init_list_expr(self, cursor: Cursor) -> nodes.ArrayInitializer:
        children_values = self.eval_children(cursor)
        return nodes.ArrayInitializer(children_values)

    def _handle_if_stmt(self, cursor: Cursor) -> nodes.IfThenElse:
        children: List[Cursor] = list(cursor.get_children())
        condition_ast = children[0]
        assert len(children) in (2, 3)
        if len(children) == 2:
            return nodes.IfThenElse(
                self.eval_single_cursor(condition_ast),
                self.eval_single_cursor(children[1]),
            )
        elif len(children) == 3:
            return nodes.IfThenElse(
                self.eval_single_cursor(condition_ast),
                self.eval_single_cursor(children[1]),
                self.eval_single_cursor(children[2]),
            )
        else:
            raise NotImplementedError(len(children))

    def _handle_namespace(self, cursor: Cursor):
        return nodes.NameSpaceDef(cursor.spelling, self.eval_children(cursor))

    def _handle_goto_stmt(self, cursor: Cursor):

        return nodes.GoToStatement(next(cursor.get_children()).spelling)

    def _handle_indirect_goto_stmt(self, cursor: Cursor):
        return nodes.GoToStatement(
            self.eval_single_cursor(next(cursor.get_children())), direct=False
        )

    def _handle_label_stmt(self, cursor: Cursor):
        return nodes.Label(
            cursor.spelling, self.eval_single_cursor(next(cursor.get_children()))
        )

    def _handle_while_stmt(self, cursor: Cursor):
        cond_ast, body_ast = self.eval_children(cursor)
        return nodes.While(cond_ast, body_ast)

    def _handle_switch_stmt(self, cursor: Cursor) -> nodes.Switch:
        condition_cursor, switch_body_cursor = cursor.get_children()
        assert switch_body_cursor.kind == CursorKind.COMPOUND_STMT
        switch_body_item_cursor: Cursor
        switch_cases: List[nodes.SwitchCase] = []
        default_procedure = None
        # Get switch items from body cursor
        for switch_body_item_cursor in switch_body_cursor.get_children():
            if switch_body_item_cursor.kind == CursorKind.CASE_STMT:
                case_cond, body = self.eval_children(switch_body_item_cursor)
                switch_cases.append(nodes.SwitchCase(case_cond, body))
            elif switch_body_item_cursor.kind == CursorKind.DEFAULT_STMT:
                body = self.eval_children(switch_body_item_cursor)[0]
                switch_cases.append(nodes.SwitchCase(nodes.DefaultStatement(), body))
            elif switch_body_item_cursor.kind in (CursorKind.BREAK_STMT,):
                if not isinstance(switch_cases[-1].body, nodes.Block):
                    switch_cases[-1].body = nodes.Block([switch_cases[-1].body])
                if switch_body_item_cursor.kind == CursorKind.BREAK_STMT:
                    switch_cases[-1].body.statements.append(
                        self.eval_single_cursor(switch_body_item_cursor)
                    )
            else:
                raise NotImplementedError
        return nodes.Switch(self.eval_single_cursor(condition_cursor), switch_cases)

    def _handle_case_stmt(self, cursor: Cursor) -> nodes.SwitchCase:
        case_cond, body = self.eval_children(cursor)
        return nodes.SwitchCase(case_cond, body)

    def _handle_do_stmt(self, cursor: Cursor):
        body_ast, pred_ast = self.eval_children(cursor)
        return nodes.DoWhile(pred_ast, body_ast)

    def _handle_for_stmt(self, cursor: Cursor):
        stmt1_cursor, cond_expr_cursor, stmt2_cursor, body_cursor = (
            split_for_loop_conditions(cursor)
        )
        # if stmt1_cursor is not None:
        stmt1_ast = self.eval_single_cursor(stmt1_cursor) if stmt1_cursor else None
        # if stmt2_cursor is not None:
        stmt2_ast = self.eval_single_cursor(stmt2_cursor) if stmt2_cursor else None
        # if cond_expr_cursor is not None:
        cond_ast = (
            self.eval_single_cursor(cond_expr_cursor) if cond_expr_cursor else None
        )
        # if body_cursor is not None:
        body_ast = self.eval_single_cursor(body_cursor) if body_cursor else None
        return nodes.For(stmt1_ast, cond_ast, stmt2_ast, body_ast)

    def _handle_return_stmt(self, cursor: Cursor) -> nodes.Return:
        children_values = self.eval_children(cursor)
        if len(children_values) > 0:
            val = children_values[0]
            return nodes.Return(val)
        else:
            return nodes.Return()

    def get_func(self, c: Cursor) -> Tuple[Cursor, FunctionDefModel]:
        if c.kind == CursorKind.DECL_REF_EXPR:
            return self._program_info.get_function_ast(
                c.spelling
            ), self._program_info.get_function_structure(c.spelling)
        elif c.kind == CursorKind.UNEXPOSED_EXPR:
            return self.get_func(first_child(c))
        else:
            raise KeyError(c.kind)

    def is_concrete_value(self, value: Any) -> bool:
        if isinstance(value, (int, float, bool, str)) or value is None:
            return True
        else:
            return False
